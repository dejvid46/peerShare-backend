<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
</head>

<body>
  <h1>Haroooo</h1>
  <script>
    const ws = new WebSocket("ws://127.0.0.1:8080/ws");

    ws.onmessage = async (event) => {
      const id = ""
      if(event.data.split(" ")[0] === "icecandidate"){
        await localConnection.addIceCandidate(JSON.parse(event.data.slice(13))).catch(error => {
          console.error('Error adding ICE candidate:', error);
        });
      }
      console.log(event.data);
    }

    const test = async () => {
      const socket = new WebSocket("ws://127.0.0.1:8080/ws");

      socket.disconnect();
    }
  </script>

  <section>
    <div>
      <form id="fileInfo">
        <input type="file" id="fileInput" name="files" />
        <input type="text" id="idInput" name="id" />
      </form>
      <button disabled id="sendFile">Send</button>
      <button disabled id="abortButton">Abort</button>
    </div>

    <div class="progress">
      <div class="label">Send progress:</div>
      <progress id="sendProgress" max="0" value="0"></progress>
    </div>

    <div class="progress">
      <div class="label">Receive progress:</div>
      <progress id="receiveProgress" max="0" value="0"></progress>
    </div>

    <div id="bitrate"></div>
    <a id="download"></a>
    <span id="status"></span>
  </section>

  <script></script>

  <script>
    let localConnection;
    let sendChannel;
    let receiveChannel;
    let fileReader;
    const bitrateDiv = document.querySelector('div#bitrate');
    const fileInput = document.querySelector('input#fileInput');
    const abortButton = document.querySelector('button#abortButton');
    const downloadAnchor = document.querySelector('a#download');
    const sendProgress = document.querySelector('progress#sendProgress');
    const receiveProgress = document.querySelector('progress#receiveProgress');
    const statusMessage = document.querySelector('span#status');
    const sendFileButton = document.querySelector('button#sendFile');

    let receiveBuffer = [];
    let receivedSize = 0;

    let bytesPrev = 0;
    let timestampPrev = 0;
    let timestampStart;
    let statsInterval = null;
    let bitrateMax = 0;

    abortButton.disabled = false;
    sendFileButton.disabled = true;
    localConnection = new RTCPeerConnection();

    sendChannel = localConnection.createDataChannel('sendDataChannel');
    sendChannel.binaryType = 'arraybuffer';

    sendChannel.addEventListener('open', onSendChannelStateChange);
    sendChannel.addEventListener('close', onSendChannelStateChange);
    sendChannel.addEventListener('error', onError);

    localConnection.addEventListener('icecandidate', async event => {
      if (event.candidate !== null) {
        ws.send("icecandidate " + JSON.stringify(event.candidate))
      }
    });

    sendFileButton.addEventListener('click', () => createConnection());
    fileInput.addEventListener('change', handleFileInputChange, false);
    abortButton.addEventListener('click', () => {
      if (fileReader && fileReader.readyState === 1) {
        fileReader.abort();
      }
    });

    async function handleFileInputChange() {
      const file = fileInput.files[0];
      if (!file) {
        console.log('No file chosen');
      } else {
        sendFileButton.disabled = false;
      }
    }


    async function createConnection() {

      try {
        // func for creating offer
        const id = document.querySelector('input#idInput').value;
        const offer = await localConnection.createOffer();
        await gotLocalDescription(offer, id);
      } catch (e) {
        console.log('Failed to create session description: ', e);
      }

      fileInput.disabled = true;
    }

    function sendData() {
      const file = fileInput.files[0];
      console.log(`File is ${[file.name, file.size, file.type, file.lastModified].join(' ')}`);

      // Handle 0 size files.
      statusMessage.textContent = '';
      downloadAnchor.textContent = '';
      if (file.size === 0) {
        bitrateDiv.innerHTML = '';
        statusMessage.textContent = 'File is empty, please select a non-empty file';
        closeDataChannels();
        return;
      }
      sendProgress.max = file.size;
      receiveProgress.max = file.size;
      const chunkSize = 16384;
      fileReader = new FileReader();
      let offset = 0;
      fileReader.addEventListener('error', error => console.error('Error reading file:', error));
      fileReader.addEventListener('abort', event => console.log('File reading aborted:', event));
      fileReader.addEventListener('load', e => {
        console.log('FileRead.onload ', e);
        sendChannel.send(e.target.result);
        offset += e.target.result.byteLength;
        sendProgress.value = offset;
        if (offset < file.size) {
          readSlice(offset);
        }
      });
      const readSlice = o => {
        console.log('readSlice ', o);
        const slice = file.slice(offset, o + chunkSize);
        fileReader.readAsArrayBuffer(slice);
      };
      readSlice(0);
    }

    // function closeDataChannels() {
    //   sendChannel.close();
    //   sendChannel = null;
    //   if (receiveChannel) {
    //     receiveChannel.close();
    //     receiveChannel = null;
    //   }
    //   localConnection.close();
    //   localConnection = null;

    //   // re-enable the file select
    //   fileInput.disabled = false;
    //   abortButton.disabled = true;
    //   sendFileButton.disabled = false;
    // }



    async function gotLocalDescription(desc, id) {
      await localConnection.setLocalDescription(desc);
      ws.send("/offer "+ id + " " + JSON.stringify(desc.localDescription))
      // ---------------------------------(here is cretaed desc)
    }

    async function gotRemoteDescription(desc) {
      await localConnection.setLocalDescription(desc);
      console.log(`Answer from remoteConnection\n ${desc.sdp}`);
      await localConnection.setRemoteDescription(desc);
    }

    // function receiveChannelCallback(event) {
    //   console.log('Receive Channel Callback');
    //   receiveChannel = event.channel;
    //   receiveChannel.binaryType = 'arraybuffer';
    //   receiveChannel.onmessage = onReceiveMessageCallback;
    //   receiveChannel.onopen = onReceiveChannelStateChange;
    //   receiveChannel.onclose = onReceiveChannelStateChange;

    //   receivedSize = 0;
    //   bitrateMax = 0;
    //   downloadAnchor.textContent = '';
    //   downloadAnchor.removeAttribute('download');
    //   if (downloadAnchor.href) {
    //     URL.revokeObjectURL(downloadAnchor.href);
    //     downloadAnchor.removeAttribute('href');
    //   }
    // }

    // function onReceiveMessageCallback(event) {
    //   receiveBuffer.push(event.data);
    //   receivedSize += event.data.byteLength;
    //   receiveProgress.value = receivedSize;

    //   // we are assuming that our signaling protocol told
    //   // about the expected file size (and name, hash, etc).
    //   const file = fileInput.files[0];
    //   if (receivedSize === file.size) {
    //     const received = new Blob(receiveBuffer);
    //     receiveBuffer = [];

    //     downloadAnchor.href = URL.createObjectURL(received);
    //     downloadAnchor.download = file.name;
    //     downloadAnchor.textContent =
    //       `Click to download '${file.name}' (${file.size} bytes)`;
    //     downloadAnchor.style.display = 'block';

    //     const bitrate = Math.round(receivedSize * 8 /
    //       ((new Date()).getTime() - timestampStart));
    //     bitrateDiv.innerHTML =
    //       `<strong>Average Bitrate:</strong> ${bitrate} kbits/sec (max: ${bitrateMax} kbits/sec)`;

    //     if (statsInterval) {
    //       clearInterval(statsInterval);
    //       statsInterval = null;
    //     }

    //     closeDataChannels();
    //   }
    // }

    function onSendChannelStateChange() {
      if (sendChannel) {
        const {
          readyState
        } = sendChannel;
        if (readyState === 'open') {
          sendData();
        }
      }
    }

    function onError(error) {
      if (sendChannel) {
        console.error('Error in sendChannel:', error);
        return;
      }
      console.log('Error in sendChannel which is already closed:', error);
    }

    async function onReceiveChannelStateChange() {
      if (receiveChannel) {
        const readyState = receiveChannel.readyState;
        if (readyState === 'open') {
          timestampStart = (new Date()).getTime();
          timestampPrev = timestampStart;
          statsInterval = setInterval(displayStats, 500);
          await displayStats();
        }
      }
    }

    // // display bitrate statistics.
    // async function displayStats() {
    //   if (localConnection && localConnection.iceConnectionState === 'connected') {
    //     const stats = await localConnection.getStats();
    //     let activeCandidatePair;
    //     stats.forEach(report => {
    //       if (report.type === 'transport') {
    //         activeCandidatePair = stats.get(report.selectedCandidatePairId);
    //       }
    //     });
    //     if (activeCandidatePair) {
    //       if (timestampPrev === activeCandidatePair.timestamp) {
    //         return;
    //       }
    //       // calculate current bitrate
    //       const bytesNow = activeCandidatePair.bytesReceived;
    //       const bitrate = Math.round((bytesNow - bytesPrev) * 8 /
    //         (activeCandidatePair.timestamp - timestampPrev));
    //       bitrateDiv.innerHTML = `<strong>Current Bitrate:</strong> ${bitrate} kbits/sec`;
    //       timestampPrev = activeCandidatePair.timestamp;
    //       bytesPrev = bytesNow;
    //       if (bitrate > bitrateMax) {
    //         bitrateMax = bitrate;
    //       }
    //     }
    //   }
    // }
  </script>
</body>

</html>